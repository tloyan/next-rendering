# Comprendre lâ€™hydratation

### ğŸ’¡ Comprendre lâ€™hydratation et gÃ©rer les Errors/Warning

## ğŸ“ Tes notes

Detaille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Dans les modules prÃ©cÃ¨dent nous avons vu

- Le rendu cotÃ© server (SSR) avec les React Server Components.
- Le rendu cotÃ© client (CSR) avec les React Client Components.

Nous allons aller plus en profondeur sur la maniÃ¨re dont Next gÃ¨re tout cela. Rappel sur le SSR

- Tout d'abord, toutes les donnÃ©es pour une page donnÃ©e sont rÃ©cupÃ©rÃ©es sur le serveur.
- Ensuite, le serveur rend le HTML pour la page.
- Le HTML, le CSS et le JavaScript de la page sont envoyÃ©s au client.
- Une interface utilisateur non interactive est affichÃ©e en utilisant le HTML et le CSS gÃ©nÃ©rÃ©s.
- Enfin, React **hydrate** l'interface utilisateur pour la rendre interactive.

![img](/course/server-rendering-without-streaming-chart.avif)

ğŸ“‘ Le liens vers la doc [https://rc.nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#what-is-streaming](https://rc.nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#what-is-streaming)

On pourrait croire que le processus `SSR` ne concerne que les composants server (RSC). Par exemple dans cet arbre de composant, on pourrait penser que le rendu SSR concerne les RSC et le rendu des RCC se fait uniquement du cotÃ© client (`CSR`).

![img](/course/rcc-rsc-tree.png)

En rÃ©alitÃ© le SSR concerne tout lâ€™arbre de composants. RSC et RCC compris. Les RCC sont donc rendus 2 fois.

Par exemple, ce RCC est rendu **une fois sur le server** sans code client (interaction client etc â€¦) Par exemple ce composant est rendu

```tsx
export default function ClientComponent() {
	const handleClick = () => {alert('Hi')}
	return (
    <button onClick={handleClick}>Click here</button>
  )
}
```

Devient SSR

```tsx
<button>Click here</button>
```

**Et un rendu ensuite sur le client avec hydration (ajout des events et code)**

```tsx
//handleClick est contenu dans le bundle/chunk.js
<button onClick={handleClick}>Click here</button>
```

On a dÃ©jÃ  vu plusieurs fois les bÃ©nÃ©fice de ce type de dÃ©coupage. Mais il faut bien prendre en compte que 2 rendus distinct sont fait. Et pour pouvoir hydrater correctement les contenus doivent Ãªtre cohÃ©rent et identiques. Si le contenu rendu sur le server, diffÃ¨re du contenu rendu sur le client, des warnings et erreurs sont lÃ©vÃ©s. Prenons lâ€™exemple suivant :

```tsx
export default function ClientComponent() {
	const date = new Date().toString()
	return (
    <div>
      {date}
    </div>
  )
}
// SSR date : Tue Jul 02 2024 14:18:53 GMT+0800
// Le rendu client arrive aprÃ¨s
// CSR date : Tue Jul 02 2024 14:18:54 GMT+0800
```

Next va alors lever une errors

```tsx
Unhandled Runtime Error
Error: Text content does not match server-rendered HTML.
See more info here: https://nextjs.org/docs/messages/react-hydration-error

Text content did not match. Server: "Tue Jul 02 2024 14:27:43 GMT+0800 (Singapore Standard Time)" Client: "Tue Jul 02 2024 14:27:44 GMT+0800 (heure de Singapour)"

En production :
Error: Minified React error #425
```

## Exercice

**ğŸ¶** Dans cet exercice tu vas devoir corriger les erreurs et warnings liÃ©s Ã  lâ€™hydratation.

- Errors :
  - Imbrication div dans `<p>`
  - Pour la `date`, split supprime le temps (HH MM SS)
- Warning
  - Utilise `suppressHydrationWarning` dans un Ã©lÃ©ment html
    - Doc : https://nextjs.org/docs/messages/react-hydration-error#solution-3-using-suppresshydrationwarning

<aside>
ğŸ’¡ Rafraichie la page (F5) et navigue pour voir la diffÃ©rence de comportement

</aside>

Fichiers

- `exercises/hydration/client-component.tsx`

## Bonus

### 1. ğŸš€ render aprÃ¨s hydration

Dans lâ€™exercice prÃ©cÃ©dent nous avons corrigÃ© les erreurs dâ€™hydrations mais les comportements ne sont pas ceux que nous souhaitons.

- La Date a du Ãªtre tronquÃ©e (or nous voulons afficher une vrai `date and time`)
- Le rendu est bleu (serveur) or il devrait Ãªtre rouge (client)

Il manque une derniÃ¨re Ã©tape (si le rendu client diffÃ¨re du serveur), il manque un rendering. Il faut garder ce schÃ©ma en tÃªte

```tsx
SSR -> Client Loading -> Hydration -> CSR (useEffect)
// utilise le composant <Phases> pour logger les differentes phases
```

Pour effectuer un rendu supplÃ©mentaire ET qui ne pose pas de problÃ¨me de dâ€™hydratation il est possible dâ€™utiliser

```tsx
const [hydrated, setHydrated] = useState(false)
...
useEffect(() => {
  setHydrated(true)
}, [])

 return <div>{hydrated? 'This is never prerendered' : 'Prerendered'}</div>
```

### Explication

- Lors du SSR `hydrated` est `false`
- Lors de lâ€™hydratation `hydrated` est toujours Ã  `false` (pas dâ€™erreur)
- AprÃ¨s hydratation nous utilisons `useEffect` pour effectuer `en re-render`

ğŸ¶ Utilise cet technique pour afficher correctement la Date et le Style (blue/Red) en te basant sur `hydrated`.

- Remet : **ğŸ¤–**`const date = new Date().toString()`

ps : tu peux supprimer `suppressHydrationWarning` car il ne devrait pas y avoir de warning sur le style

Fichiers

- `exercises/hydration/client-component.tsx`

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://nextjs.org/docs/messages/react-hydration-error](https://nextjs.org/docs/messages/react-hydration-error)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=Rendering%20AvancÃ©e&entry.533578441=08%20hydration).
